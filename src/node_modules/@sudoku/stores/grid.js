import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';
import { decodeSencode, encodeSudoku } from '@sudoku/sencode';
import { generateSudoku, solveSudoku } from '@sudoku/sudoku';
import { derived, writable } from 'svelte/store';
// import { hintCells } from './hints';
import { subscribe } from 'svelte/internal';
import { undoRedoManager } from './unredomanager';
import { cursor } from './cursor';


function createGrid() {
	const grid = writable([
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
	]);

	return {
		subscribe: grid.subscribe,

		generate(difficulty) {
			let gridData = generateSudoku(difficulty);
			grid.set(gridData); 
			//deep copy a new matrix of gridData
			let gridDataCopy = [];
			for (let y = 0; y < SUDOKU_SIZE; y++) {
				gridDataCopy[y] = [];
				for (let x = 0; x < SUDOKU_SIZE; x++) {
					gridDataCopy[y][x] = gridData[y][x];
				}
			}
			undoRedoManager.pushUndo({
				"userGrid": gridDataCopy,
				"numberOfCandidates": null,
			});
		},

		decodeSencode(sencode) {
			grid.set(decodeSencode(sencode));
		},

		get(gridStore, x, y) {
			return gridStore[y][x];
		},

		getSencode(gridStore) {
			return encodeSudoku(gridStore);
		},
	};
}

export const grid = createGrid();


function createUserGrid() {
	const userGrid = writable([
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
	]);

	grid.subscribe($grid => {
		let newGrid = [];

		for (let y = 0; y < SUDOKU_SIZE; y++) {
			newGrid[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				newGrid[y][x] = $grid[y][x];
			}
		}

		userGrid.set(newGrid);
	});




	return {
		subscribe: userGrid.subscribe,

		set: (pos, value, numberOfCandidates = null) => {
			userGrid.update($userGrid => {
				$userGrid[pos.y][pos.x] = value;
				//deep copy a new matrix
				let newGrid = [];
				for (let y = 0; y < SUDOKU_SIZE; y++) {
					newGrid[y] = [];
					for (let x = 0; x < SUDOKU_SIZE; x++) {
						newGrid[y][x] = $userGrid[y][x];
					}
				}

				if (value !== 0) {
					undoRedoManager.pushUndo({
						"userGrid": newGrid,
						"numberOfCandidates": numberOfCandidates,
					});
				}

				// clear redo stack
				undoRedoManager.clearRedo();
				undoRedoManager.isRedoEmptyFunc();


				return $userGrid;
			});
		},

		updateNothing: () => {
			console.log('in grid.js, update for fresh: ')
			userGrid.update($userGrid => {
				return $userGrid;
			});
		},


		Undo: () => {
			userGrid.update($userGrid => {
				let states = undoRedoManager.popUndo();

				//deep copy a new matrix
				let newGrid = [];
				for (let y = 0; y < SUDOKU_SIZE; y++) {
					newGrid[y] = [];
					for (let x = 0; x < SUDOKU_SIZE; x++) {
						newGrid[y][x] = states["last"]["userGrid"][y][x];
					}
				}
				//get the diff index between the current grid and the last grid
				let diffIndex = null;
				for (let y = 0; y < SUDOKU_SIZE; y++) {
					for (let x = 0; x < SUDOKU_SIZE; x++) {
						if($userGrid[y][x] !== newGrid[y][x]) {
							diffIndex = {x: x, y: y};
							break;
						}
					}
					if(diffIndex !== null) {
						break;
					}
				}
				if (diffIndex === null) {
					cursor.reset();
				} else {
					cursor.set(diffIndex["x"], diffIndex["y"]);
				}
				$userGrid = newGrid;


				if(states["cur"]["userGrid"] !== null) {
					let newCurGrid = [];
					for (let y = 0; y < SUDOKU_SIZE; y++) {
						newCurGrid[y] = [];
						for (let x = 0; x < SUDOKU_SIZE; x++) {
							newCurGrid[y][x] = states["cur"]["userGrid"][y][x];
						}
					}
					let newCurState = {
						"userGrid": newCurGrid,
						"numberOfCandidates": states["cur"]["numberOfCandidates"],
					};
					undoRedoManager.pushRedo(newCurState);
				}
				return $userGrid;
			});
		},

		Redo: () => {
			userGrid.update($userGrid => {
				let state = undoRedoManager.popRedo();
				// get the index where the difference is between the current grid and the redo grid
				let diffIndex = null;
				for (let y = 0; y < SUDOKU_SIZE; y++) {
					for (let x = 0; x < SUDOKU_SIZE; x++) {
						if($userGrid[y][x] !== state["userGrid"][y][x]) {
							diffIndex = {x: x, y: y};
							break;
						}
					}
					if(diffIndex !== null) {
						break;
					}
				}
				cursor.set(diffIndex["x"], diffIndex["y"]);
				//deep copy a new matrix
				let newGrid = [];
				for (let y = 0; y < SUDOKU_SIZE; y++) {
					newGrid[y] = [];
					for (let x = 0; x < SUDOKU_SIZE; x++) {
						newGrid[y][x] = state["userGrid"][y][x];
					}
				}
				$userGrid = newGrid;
				undoRedoManager.pushUndo({
					"userGrid": newGrid,
					"numberOfCandidates": state["numberOfCandidates"],
				});
				return $userGrid;
			});
		},

		returnHintAll: () => {
			userGrid.update($userGrid => {
				let state = undoRedoManager.getLastHintState();
				console.log("get last hint state: ", state);
				if (state === null) {
					return $userGrid;
				}

				state = state["grid"];
				console.log("get last hint state: ", state);
				//deep copy a new matrix
				let newGrid = [];
				for (let y = 0; y < SUDOKU_SIZE; y++) {
					newGrid[y] = [];
					for (let x = 0; x < SUDOKU_SIZE; x++) {
						newGrid[y][x] = state[y][x];
					}
				}
				$userGrid = newGrid;
				return $userGrid;
			}
		)}

	};
}

export const userGrid = createUserGrid();

export const invalidCells = derived(userGrid, $userGrid => {
	const _invalidCells = [];

	const addInvalid = (x, y) => {
		const xy = x + ',' + y;
		if (!_invalidCells.includes(xy)) _invalidCells.push(xy);
	};

	for (let y = 0; y < SUDOKU_SIZE; y++) {
		for (let x = 0; x < SUDOKU_SIZE; x++) {

			const value = $userGrid[y][x];

			if (value) {
				for (let i = 0; i < SUDOKU_SIZE; i++) {
					// Check the row
					if (i !== x && $userGrid[y][i] === value) {
						addInvalid(x, y);
					}

					// Check the column
					if (i !== y && $userGrid[i][x] === value) {
						addInvalid(x, i);
					}
				}

				// Check the box
				const startY = Math.floor(y / BOX_SIZE) * BOX_SIZE;
				const endY = startY + BOX_SIZE;
				const startX = Math.floor(x / BOX_SIZE) * BOX_SIZE;
				const endX = startX + BOX_SIZE;
				for (let row = startY; row < endY; row++) {
					for (let col = startX; col < endX; col++) {
						if (row !== y && col !== x && $userGrid[row][col] === value) {
							addInvalid(col, row);
						}
					}
				}
			}

		}
	}

	return _invalidCells;
}, []);