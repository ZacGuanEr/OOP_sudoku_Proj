// construct a new instance of the Undo and Redo Manager
import { get, writable } from 'svelte/store';

export const isUndoEmpty = writable(true);
export const isRedoEmpty = writable(true);
export const isLastHintStateEmpty = writable(true);



function createUndoRedoManager() {
    const undoStack = writable([]);
    const redoStack = writable([]);
    const lastHintState = writable(null);

    // The undo and redo stacks use writable stores but only return a subscribe function so they're read-only
    return {
        subscribeUndoStack: undoStack.subscribe,
        subscribeRedoStack: redoStack.subscribe,
        subscribeLastHintState: lastHintState.subscribe,


        // Push an action to the undo stack
        pushUndo(action) {
            undoStack.update(stack => {
                stack.push(action);
                this.isUndoEmptyFunc();
                console.log("stack", stack);
                return stack;
            });
            return action;
        },

        // Pop an action from the undo stack
        popUndo() {
            let last = null;
            let cur = null;
            undoStack.update(stack => {
                if (stack.length < 2) {
                    last = stack[0];
                    cur = null;
                    return stack;
                }
                last = stack[stack.length - 2];
                cur = stack[stack.length - 1];
                stack.pop();
                console.log("stack popUndo", stack);
                this.isUndoEmptyFunc();
                return stack;
            });
            return { last, cur };
        },

        // Clear the undo stack only leave the first state
        clearUndo() {
            undoStack.set([undoStack[0]]);
        },

        // Push an action to the redo stack
        pushRedo(action) {
            redoStack.update(stack => {
                stack.push(action);
                this.isRedoEmptyFunc();
                return stack;
            });
        },

        // Pop an action from the redo stack
        popRedo() {
            let item = null;
            redoStack.update(stack => {
                item = stack.pop();
                this.isRedoEmptyFunc();
                return stack;
            });

            return item;
        },

        // Clear the redo stack
        clearRedo() {
            redoStack.set([]);
        },

        // Check if the undo stack is empty
        isUndoEmptyFunc() {
            let empty = true;
            undoStack.update(stack => {
                empty = stack.length <= 1;
                return stack;
            });
            isUndoEmpty.set(empty);
            return empty;
        },

        // Check if the redo stack is empty
        isRedoEmptyFunc() {
            let empty = true;
            redoStack.update(stack => {
                empty = stack.length === 0;
                return stack;
            });
            isRedoEmpty.set(empty);
            return empty;
        },

        // Push the last hint state
        pushLastHintState(state) {
            lastHintState.set(state);
            console.log("lastHintState", state);
        },

        getLastHintState() {
            return get(lastHintState);
        },

        // Clear the last hint state
        clearLastHintState() {
            lastHintState.set(null);
        },
        
        //is last hint state empty
        isLastHintStateEmptyFunc() {
            let empty = true;
            lastHintState.update(state => {
                empty = state === null;
                return state;
            });
            isLastHintStateEmpty.set(empty);
            return empty;
        }
    };

}

export const undoRedoManager = createUndoRedoManager();