import { settings } from './settings';
import { get, writable } from 'svelte/store';
import { userGrid } from './grid';
import { candidates } from './candidates';
import { undoRedoManager } from './unredomanager';
import { strategyScheduler, runStrategyByName } from './strategies'
export const usedHints = writable(0);

function cclone(obj) {
    return JSON.parse(JSON.stringify(obj));
}

// recordHintCells只起到一个一直保留候选格子的最新候选值信息的作用，提供给键盘的禁用数字功能，没有求解功能
function createRecordHintCells() {
    const hintCells = writable({});

    return {
        subscribe: hintCells.subscribe,

        // 当用户往某个格子中输入数字时，其他多候选值的格子的剩余候选值应该一起更新
        updateAllHintCells: (solvingResult) => {
            let r_key = new Set();
            solvingResult.forEach(result => {
                const key = `${result.row},${result.col}`;
                hintCells.update($hintCells => {
                    if ($hintCells.hasOwnProperty(key)) {
                        $hintCells[key] = cclone(result);
                    }
                    r_key.add(key)
                    return $hintCells;
                })
            });
            hintCells.update($hintCells => {
                for (let key in $hintCells) {
                    if ($hintCells[key]['candidate'].length === 0) {
                        delete $hintCells[key];
                    }
                }
                return $hintCells;
            })

        },

        deleteByKey: (key) => {
            hintCells.update($hintCells => {
                if ($hintCells.hasOwnProperty(key)) {
                    delete $hintCells[key];
                }
                return $hintCells;
            })
        },

        updateHintCells: (solvingResult) => {
            solvingResult.forEach(result => {
                const key = `${result.row},${result.col}`;
                hintCells.update($hintCells => {
                    // $hintCells[key] = result.candidate;
                    $hintCells[key] = cclone(result); // 浅拷贝害死人
                    return $hintCells;
                })

            });
            console.log('in grid.js recordHintCells', hintCells)
        },

    }
}

export const recordHintCells = createRecordHintCells()


function createHintCells() {
    const hintCells = writable({});

    return {
        subscribe: hintCells.subscribe,

        applyHint: (userGrid, hints) => {
            // hints.useHint();
            const {solvingResult, strategyName} = strategyScheduler(userGrid, hints);
            hintName.updateHintName(strategyName);

            recordHintCells.updateHintCells(solvingResult);
            solvingResult.forEach(result => {
                const key = `${result.row},${result.col}`;
                const rev_key = `${result.col},${result.row}`;
                hintCells.update($hintCells => {
                    $hintCells[key] = result;
                    return $hintCells;
                })
                if (result['candidate'].length > 1) {
                    for (let i = 0; i < result['candidate'].length; i++) {
                        candidates.addByKey(rev_key, result['candidate'][i]);
                    }
                }
            });
            
        },

        // userGrid填入数字input_num后，需要从当前hintCells中移除
        updateOneCells: (key, input_num) => {
            hintCells.update($hintCells => {
                if ($hintCells.hasOwnProperty(key)) {
                    $hintCells[key]['candidate'] = $hintCells[key]['candidate'].filter(element => element !== input_num)
                }
                return $hintCells;
            })

        },

        // 当候选值的格子被用户全部填完时，立刻对当前的userGrid进行求解得到新的候选值格子
        checkAndUpdate: (userGrid, hint) => {
            hintCells.update($hintCells => {
                // console.log('in grid.js, len(hintcells)', $hintCells, Object.keys($hintCells).length);
                if (Object.keys($hintCells).length === 0) {
                    console.log('已填完当前全部候选格子')
                    const {solvingResult, strategyName} = strategyScheduler(userGrid, hint);
                    hintName.updateHintName(strategyName);
                    
                    recordHintCells.updateHintCells(solvingResult); //计入recordHintCells
                    solvingResult.forEach(result => {
                        const key = `${result.row},${result.col}`;
                        const rev_key = `${result.col},${result.row}`;
                        $hintCells[key] = cclone(result);
                        if (result['candidate'].length > 1) {
                            for (let i = 0; i < result['candidate'].length; i++) {
                                candidates.addByKey(rev_key, result['candidate'][i]);
                            }
                        }
                    });
                }
                return $hintCells;
            })
        },

        // 当用户往一个候选值格子输入值后，剩余的候选值格子应该自行调整可选的候选值
        updateAllHintCells: (userGrid, hint, hintName) => {
            hintCells.update($hintCells => {
                const solvingResult = runStrategyByName(hintName, userGrid, hint);
                const r_key = new Set();
                solvingResult.forEach(result => {
                    // const key = `${result.row},${result.col}`;
                    const key = result.row + ',' + result.col;
                    const rev_key = result.col + ',' + result.row;
                    if ($hintCells.hasOwnProperty(key)) {
                        $hintCells[key] = cclone(result);
                        if (result['candidate'].length > 1) {
                            candidates.updateByKey(rev_key, result['candidate']);
                        } else {
                            candidates.clearByKey(rev_key);
                        }
                    }
                    r_key.add(key);
                });
                // 如果用户往一个多候选值的格子中选择了错误的答案，那么有可能导致原本的候选值格子中那些只有一个候选值的格子（也就是确定性正解）的格子消失，
                // 那么需要从界面中实现相应的效果
                for (let key in $hintCells) {
                    if (!r_key.has(key)) {
                        delete $hintCells[key];
                        let tmp_arr = key.split(',');
                        tmp_arr.reverse();
                        let rev_key = tmp_arr.join(',');
                        candidates.clearByKey(rev_key);
                        // recordHintCells.deleteByKey(key);
                    }
                }
                recordHintCells.updateAllHintCells(solvingResult);
                return $hintCells;
            })
        },

        delete(x, y) {
            hintCells.update($hintCells => {
                const key = y + ',' + x;
                if ($hintCells.hasOwnProperty(key)) {
                    delete $hintCells[key];
                }
                return $hintCells;
            })
        },

        clear() {
            hintCells.update($hintCells => {
                for (let key in $hintCells) {
                    delete $hintCells[key];
                }
                userGrid.updateNothing(); // 刷新一下页面
                return $hintCells;
            });
            candidates.clearall();
        }
    }
}

export const hintCells = createHintCells();

function createHintName() {
    const hintName = writable("NULL STR");

    settings.subscribe(($hints) => {
        hintName.update($hintName => {
            if ($hints === 0) {
                $hintName = "NULL STR";
            }
            return $hintName;
        });
    });

    return {
        subscribe: hintName.subscribe,

        updateHintName(newHintName) {
            // console.log('in hints.js, HintName default is: ', defaultHints)
            hintName.update($hintName => {
                $hintName = newHintName
                return $hintName;
            });
        },

        reset() {
            hintName.set("NULL STR");
        }
    };
}

export const hintName = createHintName();

function createHints() {
    let defaultHints = 0;

    const hints = writable(0);

    // 更新设置中的Min hint level时，重新返回当前页面应当提示为关闭状态
    settings.subscribe(($settings) => {
        hints.update($hints => {
            if ($hints !== 0) {
                hintCells.clear();
            }
            $hints = 0;
            hintName.reset();
            return $hints;
        });
        defaultHints = $settings.hintsLevel;
    });

    return {
        subscribe: hints.subscribe,

        useHint() {
            console.log('in hints.js, usehint, default is: ', defaultHints)
            hints.update($hints => {
                if ($hints !== defaultHints) {
                    $hints = defaultHints;
                } else {
                    $hints = 0;
                }
                if ($hints === 0) {
                    hintName.reset();
                    hintCells.clear();
                }
                return $hints;
            });
        },

        reset() {
            hints.set(0);
        }
    };
}

export const hints = createHints();
