import { settings } from './settings';
import { writable } from 'svelte/store';
import { userGrid } from './grid'
import { candidates } from './candidates'
export const usedHints = writable(0);

function cclone(obj) {
	return JSON.parse(JSON.stringify(obj));
}

// recordHintCells只起到一个一直保留候选格子的最新候选值信息的作用，提供给键盘的禁用数字功能，没有求解功能
function createRecordHintCells() {
	const hintCells = writable({});

	return {
		subscribe: hintCells.subscribe,

        // 当用户往某个格子中输入数字时，其他多候选值的格子的剩余候选值应该一起更新
        updateAllHintCells: (lastRemainingCellResult) => {
            let r_key = new Set();
            lastRemainingCellResult.forEach(result => {
				const key = `${result.row},${result.col}`;
				hintCells.update($hintCells => {
					if ($hintCells.hasOwnProperty(key)) {
                        $hintCells[key] = cclone(result);
                    }
                    r_key.add(key)
                    return $hintCells;
				})
			});
            hintCells.update($hintCells => {
                for (let key in $hintCells){
                    if ($hintCells[key]['candidate'].length === 0) {
                        delete $hintCells[key];
                    }
                }
                return $hintCells;
            })
            
        },

        deleteByKey: (key) => {
            hintCells.update($hintCells => {
                if ($hintCells.hasOwnProperty(key)) {
                    delete $hintCells[key];
                }
                return $hintCells;
            })
        },

		updateHintCells: (lastRemainingCellResult) => {
			lastRemainingCellResult.forEach(result => {
				const key = `${result.row},${result.col}`;
				hintCells.update($hintCells => {
					// $hintCells[key] = result.candidate;
					$hintCells[key] = cclone(result); // 浅拷贝害死人
					return $hintCells;
				})
				
			});
			console.log('in grid.js recordHintCells',hintCells)
		},

	}
}

export const recordHintCells = createRecordHintCells()


function createHintCells() {
	const hintCells = writable({});

	return {
		subscribe: hintCells.subscribe,

        applyHint: (userGrid, hints) => {
			// hints.useHint();
            const lastRemainingCellResult = lastRemainingCell(userGrid, hints);
            recordHintCells.updateHintCells(lastRemainingCellResult);
            lastRemainingCellResult.forEach(result => {
				const key = `${result.row},${result.col}`;
				const rev_key = `${result.col},${result.row}`;
				hintCells.update($hintCells => {
					$hintCells[key] = result;
					return $hintCells;
				})
                // console.log(key, result['candidate'], typeof(result['candidate'][0]))
                if (result['candidate'].length > 1) {
                    for (let i = 0; i < result['candidate'].length; i++){
                        candidates.addByKey(rev_key, result['candidate'][i]);
                    }
                }
			});
		},

		// userGrid填入数字input_num后，需要从当前hintCells中移除
		updateOneCells: (key, input_num) => {
			hintCells.update($hintCells => {
				if($hintCells.hasOwnProperty(key)){
					$hintCells[key]['candidate'] = $hintCells[key]['candidate'].filter(element => element !== input_num)
				}
                // candidates.clearByKey(key);
				return $hintCells;
                
			})
			
		},

		// 当候选值的格子被用户全部填完时，立刻对当前的userGrid进行求解得到新的候选值格子
		checkAndUpdate: (userGrid, hint) => {
			hintCells.update($hintCells => {
				console.log('in grid.js, len(hintcells)', $hintCells, Object.keys($hintCells).length);
				if (Object.keys($hintCells).length === 0) {
                    console.log('已填完当前全部候选格子')
					const lastRemainingCellResult = lastRemainingCell(userGrid, hint);
					recordHintCells.updateHintCells(lastRemainingCellResult); //计入recordHintCells
					lastRemainingCellResult.forEach(result => {
						const key = `${result.row},${result.col}`;
                        const rev_key = `${result.col},${result.row}`;
						$hintCells[key] = cclone(result);
                        if (result['candidate'].length > 1) {
                            for (let i = 0; i < result['candidate'].length; i++){
                                candidates.addByKey(rev_key, result['candidate'][i]);
                            }
                        }
					});
				}
				return $hintCells;
			})
		},

        // 当用户往一个候选值格子输入值后，剩余的候选值格子应该自行调整可选的候选值
        updateAllHintCells: (userGrid, hint) => {
            hintCells.update($hintCells => {
                // console.log('in updateAllHintCells', userGrid, hint)
                const lastRemainingCellResult = lastRemainingCell(userGrid, hint);
                const r_key = new Set();
                lastRemainingCellResult.forEach(result => {
                    // const key = `${result.row},${result.col}`;
                    const key = result.row + ',' + result.col;
                    const rev_key = result.col + ',' + result.row;
                    if ($hintCells.hasOwnProperty(key)) {
                        $hintCells[key] = cclone(result);
                        if (result['candidate'].length > 1) {
                            candidates.updateByKey(rev_key, result['candidate']);
                        } else {
                            candidates.clearByKey(rev_key);
                        }
                    }
                    r_key.add(key);
                });
                // 如果用户往一个多候选值的格子中选择了错误的答案，那么有可能导致原本的候选值格子中那些只有一个候选值的格子（也就是确定性正解）的格子消失，
				// 那么需要从界面中实现相应的效果
                for (let key in $hintCells) {
                    if (!r_key.has(key)) {
                        delete $hintCells[key];
                        let tmp_arr = key.split(',');
                        tmp_arr.reverse();
                        let rev_key = tmp_arr.join(',');
                        candidates.clearByKey(rev_key);
                        // recordHintCells.deleteByKey(key);
                    }
                }
                recordHintCells.updateAllHintCells(lastRemainingCellResult);
                return $hintCells;
            })
        },

		delete(x, y) {
			hintCells.update($hintCells => {
				const key = y + ',' + x;
				if ($hintCells.hasOwnProperty(key)){
					delete $hintCells[key];
				}
				return $hintCells;
			})
		},

		clear() {
            hintCells.update($hintCells => {
                for (let key in $hintCells) {
                    delete $hintCells[key];
                }
                userGrid.updateNothing(); // 刷新一下页面
                return $hintCells;
            });
            candidates.clearall();
		}
	}
}

export const hintCells = createHintCells();


function createHints() {
	let defaultHints = 0;

	const hints = writable(0);

	// 更新设置中的Min hint level时，重新返回当前页面应当提示为关闭状态
	settings.subscribe(($settings) => {
		hints.update($hints => {
			if ($hints !== 0) {
				hintCells.clear();
			}
			$hints = 0;
			return $hints;
		});
		defaultHints = $settings.hintsLevel;
	});

	return {
		subscribe: hints.subscribe,

		useHint() {
			console.log('in hints.js, usehint, default is: ', defaultHints)
			hints.update($hints => {
				if ($hints !== defaultHints) {
					$hints = defaultHints;
				} else {
					$hints = 0;
				}
				if ($hints === 0) {
					hintCells.clear();
				}
				return $hints;
			});
		},

		reset() {
			hints.set(0);
		}
	};
}

export const hints = createHints();

function lastRemainingCellEvidence(grid, row, col) {
    const candidates = new Set([1, 2, 3, 4, 5, 6, 7, 8, 9]);
    const evidence = {
        row: [],
        col: [],
        box: []
    };

    // 检查同一行
    for (let c = 0; c < 9; c++) {
        if (grid[row][c] !== 0) {
            candidates.delete(grid[row][c]);
            evidence.row.push({ row: row, col: c, value: grid[row][c] });
        }
    }

    // 检查同一列
    for (let r = 0; r < 9; r++) {
        if (grid[r][col] !== 0) {
            candidates.delete(grid[r][col]);
            evidence.col.push({ row: r, col: col, value: grid[r][col] });
        }
    }

    // 检查同一3x3小格
    const startRow = Math.floor(row / 3) * 3;
    const startCol = Math.floor(col / 3) * 3;
    for (let r = startRow; r < startRow + 3; r++) {
        for (let c = startCol; c < startCol + 3; c++) {
            if (grid[r][c] !== 0) {
                candidates.delete(grid[r][c]);
                evidence.box.push({ row: r, col: c, value: grid[r][c] });
            }
        }
    }

    return { candidates: Array.from(candidates), evidence: evidence };
}

export function lastRemainingCell(grid, candidateNum) {
    const results = [];
	console.log('当前hint level: ', candidateNum)
    for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
            if (grid[row][col] === 0) { // 找到空白格子
                const { candidates, evidence } = lastRemainingCellEvidence(grid, row, col);

                // 如果候选值数量为candidateNum，将其加入结果数组
                if (candidates.length <= candidateNum) {
                    results.push({
                        row: row,
                        col: col,
                        candidate: candidates,
                        evidence: evidence
                    });
                }
            }
        }
    }

    return results;
}