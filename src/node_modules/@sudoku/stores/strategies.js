const STRATEGYLIB = ["LastRemainingCell", "HiddenPairs", "XWing"]
function cclone(obj) {
    return JSON.parse(JSON.stringify(obj));
}

function lastRemainingCellEvidence(grid, row, col) {
    const candidates = new Set([1, 2, 3, 4, 5, 6, 7, 8, 9]);
    const evidence = {
        row: [],
        col: [],
        box: []
    };

    // 检查同一行
    for (let c = 0; c < 9; c++) {
        if (grid[row][c] !== 0) {
            candidates.delete(grid[row][c]);
            evidence.row.push({ row: row, col: c, value: grid[row][c] });
        }
    }

    // 检查同一列
    for (let r = 0; r < 9; r++) {
        if (grid[r][col] !== 0) {
            candidates.delete(grid[r][col]);
            evidence.col.push({ row: r, col: col, value: grid[r][col] });
        }
    }

    // 检查同一3x3小格
    const startRow = Math.floor(row / 3) * 3;
    const startCol = Math.floor(col / 3) * 3;
    for (let r = startRow; r < startRow + 3; r++) {
        for (let c = startCol; c < startCol + 3; c++) {
            if (grid[r][c] !== 0) {
                candidates.delete(grid[r][c]);
                evidence.box.push({ row: r, col: c, value: grid[r][c] });
            }
        }
    }

    return { candidates: Array.from(candidates), evidence: evidence };
}

function lastRemainingCell(grid, candidateNum) {
    const results = [];
    console.log('当前hint level: ', candidateNum)
    for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
            if (grid[row][col] === 0) { // 找到空白格子
                const { candidates, evidence } = lastRemainingCellEvidence(grid, row, col);

                // 如果候选值数量为candidateNum，将其加入结果数组
                if (candidates.length <= candidateNum) {
                    results.push({
                        row: row,
                        col: col,
                        candidate: candidates,
                        evidence: evidence
                    });
                }
            }
        }
    }

    return results;
}

// 生成grid的候选值
function generateCandidates(grid) {
    const size = 9;
    const candidatesGrid = Array.from({ length: size }, () => Array.from({ length: size }, () => []));

    for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
            if (grid[r][c] === 0) { // 如果单元格为空
                const used = new Set();

                // 检查行
                for (let i = 0; i < size; i++) {
                    if (grid[r][i] !== 0) {
                        used.add(grid[r][i]);
                    }
                }

                // 检查列
                for (let i = 0; i < size; i++) {
                    if (grid[i][c] !== 0) {
                        used.add(grid[i][c]);
                    }
                }

                // 检查3x3小格
                const startRow = Math.floor(r / 3) * 3;
                const startCol = Math.floor(c / 3) * 3;
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        if (grid[startRow + i][startCol + j] !== 0) {
                            used.add(grid[startRow + i][startCol + j]);
                        }
                    }
                }

                // 生成候选数字
                for (let num = 1; num <= size; num++) {
                    if (!used.has(num)) {
                        candidatesGrid[r][c].push(num);
                    }
                }
            }
        }
    }

    return candidatesGrid;
}

function findEvidenceOfHiddenPairs(grid, candidatesGrid) {
    const size = 9;
    const evidenceGrid = Array.from({ length: size }, () => Array.from({ length: size }, () => []));

    function findHiddenPairsInUnits(units) {
        for (const unit of units) {
            const frequency = Array.from({ length: size + 1 }, () => []);
            unit.forEach(([r, c]) => {
                candidatesGrid[r][c].forEach(num => {
                    frequency[num].push([r, c]);
                });
            });

            const pairs = [];
            for (let num1 = 1; num1 <= size; num1++) {
                if (frequency[num1].length === 2) {
                    for (let num2 = num1 + 1; num2 <= size; num2++) {
                        if (frequency[num2].length === 2 &&
                            frequency[num1][0][0] === frequency[num2][0][0] &&
                            frequency[num1][0][1] === frequency[num2][0][1] &&
                            frequency[num1][1][0] === frequency[num2][1][0] &&
                            frequency[num1][1][1] === frequency[num2][1][1]) {
                            pairs.push({ nums: [num1, num2], cells: frequency[num1] });
                        }
                    }
                }
            }

            pairs.forEach(({ nums, cells }) => {
                cells.forEach(([r, c]) => {
                    candidatesGrid[r][c] = nums;
                    evidenceGrid[r][c] = cells;
                });
            });
        }
    }

    const rows = Array.from({ length: size }, (_, r) => Array.from({ length: size }, (_, c) => [r, c]));
    const cols = Array.from({ length: size }, (_, c) => Array.from({ length: size }, (_, r) => [r, c]));
    const boxes = Array.from({ length: size }, (_, i) => {
        const startRow = Math.floor(i / 3) * 3;
        const startCol = (i % 3) * 3;
        return Array.from({ length: 9 }, (_, j) => [startRow + Math.floor(j / 3), startCol + (j % 3)]);
    });

    findHiddenPairsInUnits(rows);
    findHiddenPairsInUnits(cols);
    findHiddenPairsInUnits(boxes);

    return evidenceGrid;
}

function applyHiddenPairs(grid, maxCandidates) {
    const candidatesGrid = generateCandidates(grid);
    const evidenceGrid = findEvidenceOfHiddenPairs(grid, candidatesGrid);

    const result = [];
    for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
            if (grid[r][c] === 0 && candidatesGrid[r][c].length <= maxCandidates) {
                result.push({
                    row: r,
                    col: c,
                    candidate: candidatesGrid[r][c],
                    evidence: evidenceGrid[r][c]
                });
            }
        }
    }
    return result;
}

function findEvidenceOfHiddenPairsOfXWing(grid, candidatesGrid) {
    const size = 9;
    const evidenceGrid = Array.from({ length: size }, () => Array.from({ length: size }, () => []));

    function findXWingInLines(lines, isRow) {
        for (let num = 1; num <= size; num++) {
            const candidateLines = lines.map((line, index) => {
                const positions = line.map((candidates, pos) => candidates.includes(num) ? pos : -1).filter(pos => pos !== -1);
                return { index, positions };
            }).filter(line => line.positions.length === 2);

            for (let i = 0; i < candidateLines.length - 1; i++) {
                for (let j = i + 1; j < candidateLines.length; j++) {
                    const line1 = candidateLines[i];
                    const line2 = candidateLines[j];

                    if (line1.positions[0] === line2.positions[0] && line1.positions[1] === line2.positions[1]) {
                        const pos1 = line1.positions[0];
                        const pos2 = line1.positions[1];
                        const coords = [
                            isRow ? [line1.index, pos1] : [pos1, line1.index],
                            isRow ? [line1.index, pos2] : [pos2, line1.index],
                            isRow ? [line2.index, pos1] : [pos1, line2.index],
                            isRow ? [line2.index, pos2] : [pos2, line2.index]
                        ];

                        // 更新候选值并记录证据
                        coords.forEach(([r, c]) => {
                            if (candidatesGrid[r][c].includes(num)) {
                                evidenceGrid[r][c].push(...coords);
                            }
                        });
                    }
                }
            }
        }
    }

    const rows = Array.from({ length: size }, (_, r) => Array.from({ length: size }, (_, c) => candidatesGrid[r][c]));
    const cols = Array.from({ length: size }, (_, c) => Array.from({ length: size }, (_, r) => candidatesGrid[r][c]));

    findXWingInLines(rows, true);
    findXWingInLines(cols, false);

    return evidenceGrid;
}

function applyXWing(grid, maxCandidates) {
    const candidatesGrid = generateCandidates(grid);
    const evidenceGrid = findEvidenceOfHiddenPairsOfXWing(grid, candidatesGrid);

    const result = [];
    for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
            if (grid[r][c] === 0 && candidatesGrid[r][c].length <= maxCandidates) {
                result.push({
                    row: r,
                    col: c,
                    candidate: candidatesGrid[r][c],
                    evidence: evidenceGrid[r][c]
                });
            }
        }
    }
    return result;
}


function mergeAndIntersectResults(results) {
    const merged = {};
    if (!results) {
        return results;
    }

    results.forEach(result => {
        result.forEach(({ row, col, candidate, evidence }) => {
            const key = `${row}-${col}`;
            if (!merged[key]) {
                merged[key] = { row, col, candidate: new Set(candidate), evidence: new Set() };
            } else {
                if (candidate.length === 1) {
                    // 只有一个候选值的格子，取并集
                    candidate.forEach(num => merged[key].candidate.add(num));
                } else {
                    // 多于一个候选值的格子，取交集
                    merged[key].candidate = new Set([...merged[key].candidate].filter(x => candidate.includes(x)));
                }
            }

            // 合并证据
            // evidence.forEach(e => merged[key].evidence.add(JSON.stringify(e)));
        });
    });

    // 将 Set 转换回数组，并解析证据
    return Object.values(merged).map(({ row, col, candidate, evidence }) => ({
        row,
        col,
        candidate: Array.from(candidate),
        evidence: Array.from(evidence).map(e => JSON.parse(e))
    }));
}

function getRandomStrategies(arr) {
    // 生成一个随机数量，范围是1到数组的长度
    const numElements = Math.floor(Math.random() * arr.length) + 1;

    const shuffled = arr.slice(); // 复制数组以避免修改原数组
    for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]; // 交换元素
    }

    return shuffled.slice(0, numElements);
}

export function strategyScheduler(userGrid, hints) {
    let runningStrategyNames = getRandomStrategies(STRATEGYLIB);
    let usedStrategyNames = runningStrategyNames.join('+');
    
    const solvingResults = [];
    for (let i = 0; i < runningStrategyNames.length; i++) {
        const strategyName = runningStrategyNames[i];
        const solvingRes = cclone(runStrategyByName(strategyName, userGrid, hints));
        if (solvingRes.length > 0) {
            solvingResults.push(solvingRes);
        }
    }
    let solvingResults1= [];
    if (solvingResults.length > 0) {
        solvingResults1 = mergeAndIntersectResults(solvingResults);
    }
    const solvingResult = cclone(solvingResults1);
    return {solvingResult, usedStrategyNames};
}

export function runStrategyByName(strategyName, userGrid, hints) {
    let solvingResult = {};
    if (strategyName === "LastRemainingCell") {
        solvingResult = lastRemainingCell(userGrid, hints);
    } else if (strategyName === "HiddenPairs") {
        solvingResult = applyHiddenPairs(userGrid, hints);
    } else if (strategyName === "XWing") {
        solvingResult = applyXWing(userGrid, hints);
    } else {
        solvingResult = lastRemainingCell(userGrid, hints);
    }
    return solvingResult;
}