function lastRemainingCellEvidence(grid, row, col) {
    const candidates = new Set([1, 2, 3, 4, 5, 6, 7, 8, 9]);
    const evidence = {
        row: [],
        col: [],
        box: []
    };

    // 检查同一行
    for (let c = 0; c < 9; c++) {
        if (grid[row][c] !== 0) {
            candidates.delete(grid[row][c]);
            evidence.row.push({ row: row, col: c, value: grid[row][c] });
        }
    }

    // 检查同一列
    for (let r = 0; r < 9; r++) {
        if (grid[r][col] !== 0) {
            candidates.delete(grid[r][col]);
            evidence.col.push({ row: r, col: col, value: grid[r][col] });
        }
    }

    // 检查同一3x3小格
    const startRow = Math.floor(row / 3) * 3;
    const startCol = Math.floor(col / 3) * 3;
    for (let r = startRow; r < startRow + 3; r++) {
        for (let c = startCol; c < startCol + 3; c++) {
            if (grid[r][c] !== 0) {
                candidates.delete(grid[r][c]);
                evidence.box.push({ row: r, col: c, value: grid[r][c] });
            }
        }
    }

    return { candidates: Array.from(candidates), evidence: evidence };
}

function lastRemainingCell(grid, candidateNum) {
    const results = [];
    console.log('当前hint level: ', candidateNum)
    for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
            if (grid[row][col] === 0) { // 找到空白格子
                const { candidates, evidence } = lastRemainingCellEvidence(grid, row, col);

                // 如果候选值数量为candidateNum，将其加入结果数组
                if (candidates.length <= candidateNum) {
                    results.push({
                        row: row,
                        col: col,
                        candidate: candidates,
                        evidence: evidence
                    });
                }
            }
        }
    }

    return results;
}

// 生成grid的候选值
function generateCandidates(grid) {
    const size = 9;
    const candidatesGrid = Array.from({ length: size }, () => Array.from({ length: size }, () => []));

    for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
            if (grid[r][c] === 0) { // 如果单元格为空
                const used = new Set();

                // 检查行
                for (let i = 0; i < size; i++) {
                    if (grid[r][i] !== 0) {
                        used.add(grid[r][i]);
                    }
                }

                // 检查列
                for (let i = 0; i < size; i++) {
                    if (grid[i][c] !== 0) {
                        used.add(grid[i][c]);
                    }
                }

                // 检查3x3小格
                const startRow = Math.floor(r / 3) * 3;
                const startCol = Math.floor(c / 3) * 3;
                for (let i = 0; i < 3; i++) {
                    for (let j = 0; j < 3; j++) {
                        if (grid[startRow + i][startCol + j] !== 0) {
                            used.add(grid[startRow + i][startCol + j]);
                        }
                    }
                }

                // 生成候选数字
                for (let num = 1; num <= size; num++) {
                    if (!used.has(num)) {
                        candidatesGrid[r][c].push(num);
                    }
                }
            }
        }
    }

    return candidatesGrid;
}

function findEvidenceOfHiddenPairs(grid, candidatesGrid) {
    const size = 9;
    const evidenceGrid = Array.from({ length: size }, () => Array.from({ length: size }, () => []));

    function findHiddenPairsInUnits(units) {
        for (const unit of units) {
            const frequency = Array.from({ length: size + 1 }, () => []);
            unit.forEach(([r, c]) => {
                candidatesGrid[r][c].forEach(num => {
                    frequency[num].push([r, c]);
                });
            });

            const pairs = [];
            for (let num1 = 1; num1 <= size; num1++) {
                if (frequency[num1].length === 2) {
                    for (let num2 = num1 + 1; num2 <= size; num2++) {
                        if (frequency[num2].length === 2 &&
                            frequency[num1][0][0] === frequency[num2][0][0] &&
                            frequency[num1][0][1] === frequency[num2][0][1] &&
                            frequency[num1][1][0] === frequency[num2][1][0] &&
                            frequency[num1][1][1] === frequency[num2][1][1]) {
                            pairs.push({ nums: [num1, num2], cells: frequency[num1] });
                        }
                    }
                }
            }

            pairs.forEach(({ nums, cells }) => {
                cells.forEach(([r, c]) => {
                    candidatesGrid[r][c] = nums;
                    evidenceGrid[r][c] = cells;
                });
            });
        }
    }

    const rows = Array.from({ length: size }, (_, r) => Array.from({ length: size }, (_, c) => [r, c]));
    const cols = Array.from({ length: size }, (_, c) => Array.from({ length: size }, (_, r) => [r, c]));
    const boxes = Array.from({ length: size }, (_, i) => {
        const startRow = Math.floor(i / 3) * 3;
        const startCol = (i % 3) * 3;
        return Array.from({ length: 9 }, (_, j) => [startRow + Math.floor(j / 3), startCol + (j % 3)]);
    });

    findHiddenPairsInUnits(rows);
    findHiddenPairsInUnits(cols);
    findHiddenPairsInUnits(boxes);

    return evidenceGrid;
}

function applyHiddenPairs(grid, maxCandidates) {
    const candidatesGrid = generateCandidates(grid);
    const evidenceGrid = findEvidenceOfHiddenPairs(grid, candidatesGrid);

    const result = [];
    for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
            if (grid[r][c] === 0 && candidatesGrid[r][c].length <= maxCandidates) {
                result.push({
                    row: r,
                    col: c,
                    candidate: candidatesGrid[r][c],
                    evidence: evidenceGrid[r][c]
                });
            }
        }
    }
    return result;
}

function findEvidenceOfHiddenPairsOfXWing(grid, candidatesGrid) {
    const size = 9;
    const evidenceGrid = Array.from({ length: size }, () => Array.from({ length: size }, () => []));

    function findXWingInLines(lines, isRow) {
        for (let num = 1; num <= size; num++) {
            const candidateLines = lines.map((line, index) => {
                const positions = line.map((candidates, pos) => candidates.includes(num) ? pos : -1).filter(pos => pos !== -1);
                return { index, positions };
            }).filter(line => line.positions.length === 2);

            for (let i = 0; i < candidateLines.length - 1; i++) {
                for (let j = i + 1; j < candidateLines.length; j++) {
                    const line1 = candidateLines[i];
                    const line2 = candidateLines[j];

                    if (line1.positions[0] === line2.positions[0] && line1.positions[1] === line2.positions[1]) {
                        const pos1 = line1.positions[0];
                        const pos2 = line1.positions[1];
                        const coords = [
                            isRow ? [line1.index, pos1] : [pos1, line1.index],
                            isRow ? [line1.index, pos2] : [pos2, line1.index],
                            isRow ? [line2.index, pos1] : [pos1, line2.index],
                            isRow ? [line2.index, pos2] : [pos2, line2.index]
                        ];

                        // 更新候选值并记录证据
                        coords.forEach(([r, c]) => {
                            if (candidatesGrid[r][c].includes(num)) {
                                evidenceGrid[r][c].push(...coords);
                            }
                        });
                    }
                }
            }
        }
    }

    const rows = Array.from({ length: size }, (_, r) => Array.from({ length: size }, (_, c) => candidatesGrid[r][c]));
    const cols = Array.from({ length: size }, (_, c) => Array.from({ length: size }, (_, r) => candidatesGrid[r][c]));

    findXWingInLines(rows, true);
    findXWingInLines(cols, false);

    return evidenceGrid;
}

function applyXWing(grid, maxCandidates) {
    const candidatesGrid = generateCandidates(grid);
    const evidenceGrid = findEvidenceOfHiddenPairsOfXWing(grid, candidatesGrid);

    const result = [];
    for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
            if (grid[r][c] === 0 && candidatesGrid[r][c].length <= maxCandidates) {
                result.push({
                    row: r,
                    col: c,
                    candidate: candidatesGrid[r][c],
                    evidence: evidenceGrid[r][c]
                });
            }
        }
    }
    return result;
}

export function strategyScheduler(userGrid, hints) {
    const randomNumber = Math.floor(Math.random() * 100); // 生成0到99之间的随机整数
    let solvingResult = null;
    let strategyName = null;
    if (randomNumber % 3 === 0) {
        solvingResult = lastRemainingCell(userGrid, hints);
        strategyName = "LastRemainingCell";
    } else if (randomNumber % 3 === 1) {
        solvingResult = applyHiddenPairs(userGrid, hints);
        strategyName = "HiddenPairs";
    } else {
        solvingResult = applyXWing(userGrid, hints);
        strategyName = "XWing";
    }
    return {solvingResult, strategyName};
}

export function runStrategyByName(strategyName, userGrid, hints) {
    let solvingResult = null;
    if (strategyName === "LastRemainingCell") {
        solvingResult = lastRemainingCell(userGrid, hints);
    } else if (strategyName === "HiddenPairs") {
        solvingResult = applyHiddenPairs(userGrid, hints);
    } else if (strategyName === "XWing") {
        solvingResult = applyXWing(userGrid, hints);
    } else {
        solvingResult = lastRemainingCell(userGrid, hints);
    }
    return solvingResult;
}